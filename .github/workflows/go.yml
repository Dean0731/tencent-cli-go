name: Release Go Application

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        goos: [linux, windows]
        goarch: [amd64, arm64]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23.7'
          cache: true

      # ========== æ„å»º ==========
      - name: Build ${{ matrix.goos }}/${{ matrix.goarch }}
        run: |
          if [ "${{ matrix.goos }}" = "windows" ]; then
            BINARY_NAME="tencent_cli_go.exe"
          else
            BINARY_NAME="tencent_cli_go"
          fi
          CGO_ENABLED=0 GOOS=${{ matrix.goos }} GOARCH=${{ matrix.goarch }} \
          go build -ldflags='-s -w -X main.VERSION=${{ github.ref_name }}' -o "$BINARY_NAME" .

      # ========== æ‰“åŒ… ==========
      - name: Package ${{ matrix.goos }}/${{ matrix.goarch }}
        id: package_binary
        run: |
          PKG_DIR="tencent_cli_go-${{ github.ref_name }}-${{ matrix.goos }}-${{ matrix.goarch }}"
          mkdir -p "$PKG_DIR"
          
          # è¾“å‡ºå½“å‰è·¯å¾„å’Œæ–‡ä»¶åˆ—è¡¨
          echo "ğŸ“ å½“å‰ç›®å½•: $(pwd)"
          ls -la .
          
          # ç¼–è¯‘äºŒè¿›åˆ¶
          if [ "${{ matrix.goos }}" = "windows" ]; then
            BINARY_NAME="tencent_cli_go.exe"
          else
            BINARY_NAME="tencent_cli_go"
          fi
          
          CGO_ENABLED=0 GOOS=${{ matrix.goos }} GOARCH=${{ matrix.goarch }} \
          go build -ldflags='-s -w -X main.VERSION=${{ github.ref_name }}' -o "$BINARY_NAME" .

          # æ£€æŸ¥æ˜¯å¦ç¼–è¯‘æˆåŠŸ
          if [ ! -f "$BINARY_NAME" ]; then
            echo "âŒ ç¼–è¯‘å¤±è´¥: $BINARY_NAME ä¸å­˜åœ¨"
            ls -la .  # åˆ—å‡ºæ‰€æœ‰æ–‡ä»¶
            exit 1
          fi

          # å¤åˆ¶åˆ° PKG_DIR
          cp "$BINARY_NAME" "$PKG_DIR/"
          cp readme.md "$PKG_DIR/" || echo "âš ï¸ README.md not found"
          cp LICENSE "$PKG_DIR/" || echo "âš ï¸ LICENSE not found"
          cp CHANGELOG.md "$PKG_DIR/" || echo "âš ï¸ CHANGELOG.md not found"

          # å‹ç¼©
          if [ "${{ matrix.goos }}" = "windows" ]; then
            zip -r "${PKG_DIR}.zip" "$PKG_DIR/"
            ASSET_PATH="${PKG_DIR}.zip"
          else
            tar -czf "${PKG_DIR}.tar.gz" "$PKG_DIR/"
            ASSET_PATH="${PKG_DIR}.tar.gz"
          fi

          # æ£€æŸ¥å‹ç¼©æ–‡ä»¶æ˜¯å¦å­˜åœ¨
          if [ ! -f "$ASSET_PATH" ]; then
            echo "âŒ å‹ç¼©å¤±è´¥: $ASSET_PATH ä¸å­˜åœ¨"
            ls -la *.zip *.tar.gz
            exit 1
          fi

          # è¾“å‡ºå˜é‡
          echo "asset_path=$ASSET_PATH" >> $GITHUB_OUTPUT
          echo "asset_name=$(basename "$ASSET_PATH")" >> $GITHUB_OUTPUT

          # è°ƒè¯•ï¼šæ‰“å°ç»“æœ
          echo "âœ… asset_path = $ASSET_PATH"
          echo "âœ… asset_name = $(basename "$ASSET_PATH")"

      # ========== æå– Changelog å¹¶åˆ›å»º Releaseï¼ˆä»… linux/amd64 æ‰§è¡Œï¼‰==========
      - name: Extract Changelog and Create Release
        if: matrix.goos == 'linux' && matrix.goarch == 'amd64'
        id: create_release
        uses: actions/github-script@v7
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const { readFileSync } = require('fs');
            const tagName = context.ref.replace('refs/tags/', '');

            // è¯»å– CHANGELOG.md
            let changelogContent;
            try {
              changelogContent = readFileSync('CHANGELOG.md', 'utf8');
            } catch (err) {
              core.setFailed('âŒ CHANGELOG.md æ–‡ä»¶æœªæ‰¾åˆ°ï¼');
              throw err;
            }

            // æŒ‰è¡Œæ‹†åˆ†
            const lines = changelogContent.split('\n');
            let inSection = false;
            let changelogBody = '';

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i].trim();

              // åŒ¹é…å½“å‰ç‰ˆæœ¬ï¼š## [v1.0.0] æˆ– ## v1.0.0
              if (line.startsWith(`## [${tagName}]`) || line.startsWith(`## ${tagName}`)) {
                inSection = true;
                // ä»ä¸‹ä¸€è¡Œå¼€å§‹æ”¶é›†å†…å®¹
                let content = [];
                for (let j = i + 1; j < lines.length; j++) {
                  const nextLine = lines[j].trim();

                  // å¦‚æœé‡åˆ°ä¸‹ä¸€ä¸ªç‰ˆæœ¬æ ‡é¢˜ï¼ˆ## [v... æˆ– ## v...ï¼‰ï¼Œåœæ­¢
                  if (nextLine.startsWith('## [') || (nextLine.startsWith('## ') && nextLine.includes('] -') || nextLine.match(/## v\d+\.\d+\.\d+/))) {
                    break;
                  }

                  content.push(lines[j]); // ä¿ç•™åŸå§‹æ ¼å¼ï¼ˆåŒ…æ‹¬ç¼©è¿›ã€æ¢è¡Œï¼‰
                }

                changelogBody = content.join('\n').trim();
                break;
              }
            }

            // å¦‚æœæ²¡æ‰¾åˆ°å†…å®¹
            if (!changelogBody) {
              changelogBody = `æœªåœ¨ CHANGELOG.md ä¸­æ‰¾åˆ°ç‰ˆæœ¬ ${tagName} çš„æ›´æ–°è®°å½•ã€‚`;
            }

            // æ·»åŠ æ ‡é¢˜
            changelogBody = `### ğŸ“ æ›´æ–°æ—¥å¿—\n\n${changelogBody}`;

            // åˆ›å»ºæˆ–è·å– Release
            let release;
            try {
              release = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName
              });
              console.log(`â„¹ï¸ Release å·²å­˜åœ¨: ${release.data.html_url}`);
            } catch (error) {
              if (error.status === 404) {
                release = await github.rest.repos.createRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag_name: tagName,
                  name: `Release ${tagName}`,
                  body: changelogBody,
                  draft: false,
                  prerelease: false
                });
                console.log(`âœ… æˆåŠŸåˆ›å»º Release: ${release.data.html_url}`);
              } else {
                core.setFailed(`âŒ è·å– Release å¤±è´¥: ${error.message}`);
                throw error;
              }
            }

            // è¾“å‡º release_id
            core.setOutput('id', release.data.id);
            core.setOutput('html_url', release.data.html_url);

      # ========== æ‰€æœ‰å¹³å°ä¸Šä¼ èµ„äº§ ==========
      - name: Upload Release Asset
        uses: actions/github-script@v7
        env:
          ASSET_PATH: ${{ steps.package_binary.outputs.asset_path }}
          ASSET_NAME: ${{ steps.package_binary.outputs.asset_name }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const { readFileSync } = require('fs');
            const assetPath = process.env.ASSET_PATH;
            const assetName = process.env.ASSET_NAME;
            const tagName = context.ref.replace('refs/tags/', '');

            if (!assetPath || !assetName) {
              throw new Error('âŒ asset_path æˆ– asset_name ä¸ºç©ºï¼Œè¯·æ£€æŸ¥ package_binary æ­¥éª¤æ˜¯å¦æ­£ç¡®è¾“å‡º');
            }

            console.log(`ğŸ“ å‡†å¤‡ä¸Šä¼ : ${assetName} (è·¯å¾„: ${assetPath})`);

            // é‡è¯•è·å– Release
            async function getReleaseWithRetry(retries = 15, delay = 10000) {
              for (let i = 0; i < retries; i++) {
                try {
                  const { data: release } = await github.rest.repos.getReleaseByTag({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    tag: tagName
                  });
                  console.log(`âœ… æ‰¾åˆ° Release: ${release.html_url}`);
                  return release;
                } catch (error) {
                  if (error.status === 404) {
                    if (i === retries - 1) {
                      throw new Error(`âŒ è¶…æ—¶ï¼šæœªæ‰¾åˆ° Release ${tagName}`);
                    }
                    console.log(`â³ ç­‰å¾… Release... (${i + 1}/${retries})`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                  } else {
                    throw error;
                  }
                }
              }
            }

            const release = await getReleaseWithRetry();

            const fileBuffer = readFileSync(assetPath);
            const fileSize = fileBuffer.length;
            const contentType = assetName.endsWith('.zip') 
              ? 'application/zip' 
              : 'application/gzip';

            console.log(`ğŸ“¤ ä¸Šä¼ ä¸­: ${assetName} (${fileSize} bytes)`);

            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.id,
              name: assetName,
              data: fileBuffer,
              headers: {
                'content-type': contentType,
                'content-length': fileSize
              }
            });

            console.log(`âœ… ä¸Šä¼ æˆåŠŸ: ${assetName}`);